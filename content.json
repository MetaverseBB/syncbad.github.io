{"pages":[],"posts":[{"title":"Android 的 v-a&#x2F;b分区简单理解","text":"基础理解我们可以直接把v-a/b分区理解成，当你在使用手机，进行系统升级，系统会把升级内容存放在A分区，你继续使用B分区，前面的V就是虚拟的意思（virtual）。在尽量不影响你使用的开机情况下进行升级，取消了在rec分区进行升级的复杂操作。 详细理解（我的浅见）首先说结构。传统结构中，存在rec，boot，system分区，在V-ab结构中，抛弃了提到的这三个分区，取而代之的是：boot_a,system_a,boot_b,system_b。这就是v-ab。 首先要介绍Δ（delta，小写δ）文件。Δ文件就是cow(copy-on-write)文件，字面意思，具体可以看wikipedia的解释:https://en.wikipedia.org/wiki/Copy-on-write 。然后我们首先打开谷歌的官方文档：https://source.android.com/devices/tech/ota/virtual_ab#device-mapper ，里面请看：这个super分区（超级分区） 这个分区，就是用来储存Δ文件的。那么在进行一些比较大的升级的时候，Δ文件可能比较大，预分的super分区可能存在不足的现象。这个时候，会把多余的文件储存到/data下。这个情况基本只发生在Android11上，因为Android10预留了两倍逻辑分区的空间。Android10的VAB分区本身就不是原生的，是根据动态分区改装而来的。 那么，当你在Android11手机上，开机状态下进行升级时，在哪里查看文件呢？你可以查看下面这个路径：/data/gsi/ota，下面存在一些列的带有cow的.img文件。至于存在与哪里，就看系统分配的super分区的逻辑空间大小了。 现在再看官方文档：https://source.android.com/devices/tech/ota/virtual_ab#dm-snapshot-overview ，下面的DM概述。其中： 快照设备是使用snapshot目标创建的。写入快照设备将写入COW设备。从快照设备读取是从基本设备读取还是从COW设备读取，具体取决于快照是否更改了所访问的数据。 这就说明了，为什么在生成完cow文件之后，系统把bootContral.hal的合并状态改为snapshoted了。如果当前你在操作a空间，那么系统会把你当前的系统分区从system_a改为system_a_cow，然后会开始把你切换到B分区，你至此仍然可以正常使用手机，只是切换过程中你使用手机，可能会有一点点卡感觉。 在生成完cow文件之后，系统这时提示我们重启。我们发现，重启依然会有一个时间需要等待，和之前的rec读cmd安装差不多啊。那么到底这个时间系统在做什么呢？ 首先我们默认你升级前使用的是a分区。在你关机后，由于之前的hal文件改为了snapshoted，这个时候系统会把对应的旧系统分区和Δ文件进行合并。不过这个时候单纯是加载到内存中，不是合并的二进制文件。如果这个时候重启成功，那么系统会在开机后，偷偷地合并剩余的二进制文件，这个时候系统会把bootContral.hal的合并状态改为merging，合并中。如果存在开机失败的状态，那么系统则直接读取老系统文件进行回滚（其实不是回滚，直接读取就完事了）。直至开机成功，hal文件的合并状态才会被置空，等待下一次升级。 看到这里你会问了，这个逻辑其实和之前的读取刷机脚本进行升级差不多啊。其实这里最大的差别，除了分区升级外，就是一个最厉害的点：在bootContral.hal的状态为合并中（merging）的时候，你可以随意重启手机。而只有在bootContral.hal的状态为合并中的时候，也才算是真正的系统升级状态。接下来解释为什么很多手机看起来依然和之前的手机升级效果差不多？其实很多厂商会估计把这个合并过程加上动画……让你看起来手机没有进入系统，实际上手机是进入系统了，只是没有启动桌面，给你看这个合并进度而已。如果这个时候你重启，在重启后，手机会继续合并剩余的文件，减少了崩溃的情况。即使崩溃，手机也会直接读取旧系统文件，你依然可以重新进行升级！ 总结 其实这只是我简单的理解。也看了网上的一些文章。因为谷歌对v-ab的描写基本等于没说… 看了大神们对v-ab的解释之后，我才知道这玩意其实挺糊弄（中间替换系统分区名字那一段…），也挺牛的，减少了你每月一次可能由于升级导致系统崩溃的情况，也开始逐渐抛弃bl…… 唯一对不起的就是刷机佬，刷机学习成本再次提高…","link":"/2021/09/11/android-v-ab/"},{"title":"Tron官方库交易代码","text":"因为Bintray下线导致之前TRONJ包下载不下来，所以这里记录一下tron的trident-java交易的逻辑。 首先你需要打包或者导入之后，官方的库在Github：tronprotocol/trident 下面是交易方法 12345678910111213141516171819202122232425public void trxTransfer(String privateKey, String fromAddress, String toAddress, BigDecimal amount, String memo) { ApiWrapper client; //创建 -&gt; 签名 -&gt; 广播 -&gt; （等待上链） -&gt; 在链上查询到交易信息 if (com.mno.hdwallet.BuildConfig.isTest) { client = ApiWrapper.ofShasta(privateKey.replace(&quot;0x&quot;, &quot;&quot;)); } else { client = ApiWrapper.ofMainnet(privateKey.replace(&quot;0x&quot;, &quot;&quot;), &quot;8f467acf-7a4b-4487-95f6-4410a7a17218&quot;); } BigDecimal realValue = amount.multiply(BigDecimal.valueOf(Math.pow(10.0, 6))); ByteString rawFrom = parseAddress(fromAddress); ByteString rawTo = parseAddress(toAddress); Contract.TransferContract req = Contract.TransferContract.newBuilder() .setOwnerAddress(rawFrom) .setToAddress(rawTo) .setAmount(realValue.longValue()) .build(); Response.TransactionExtention txnExt = client.blockingStub.createTransaction2(req); System.out.println(&quot;txn id =&gt; &quot; + id); TransactionBuilder builder = new TransactionBuilder(txnExt.getTransaction()); builder.setMemo(memo); Chain.Transaction signedTxn = client.signTransaction(builder.build()); System.out.println(signedTxn.toString()); Response.TransactionReturn ret = client.blockingStub.broadcastTransaction(signedTxn); System.out.println(&quot;======== Result ========\\n&quot; + ret.toString()); }","link":"/2021/09/04/fuck-tron-sdk/"},{"title":"Github Package 的相关使用","text":"在Github Package上发布你的包 右上角头像 → setting → Developer settings → Personal access tokens Generate new toke 以上两步可以直接点击传送门到达 https://github.com/settings/tokens/new 选择期限 选中write:packages，系统会自动勾选其他必须权限 记录下来生成的Token 在Android Studio（或者其他编译器，这里专指AS）中创建github.properties文件，注意：记得在.gitignore 文件中添加遗忘，避免上传你的token文件…… 然后添加 12gpr.usr=GITHUB_USERIDgpr.key=PERSONAL_ACCESS_TOKEN 到文件中，这里的值不需要加任何引号。然后在你需要发布的包的build.gradle中： 12345678910111213141516171819202122232425262728293031323334353637383940// 在你的库的顶部添加这个pluginapply plugin: 'maven-publish' // 配置配置文件def githubProperties = new Properties()githubProperties.load(new FileInputStream(rootProject.file(&quot;github.properties&quot;))) //版本名def getVersionName = { -&gt; return &quot;1.0.0&quot;}//库名def getArtificatId = { -&gt; return &quot;my-maven-packge&quot;}publishing { publications { bar(MavenPublication) { //你的库的id groupId 'com.mylib' artifactId getArtificatId() version getVersionName() artifact(&quot;$buildDir/outputs/aar/${getArtificatId()}-release.aar&quot;) } } repositories { maven { name = &quot;my-maven-packge&quot; url = uri(&quot;https://maven.pkg.github.com/你的账户/你的仓库&quot;) credentials { username = githubProperties['gpr.usr'] ?: System.getenv(&quot;GPR_USER&quot;) password = githubProperties['gpr.key'] ?: System.getenv(&quot;GPR_API_KEY&quot;) } } }} 准备发布首先你需要检查你的项目的build/outputs/aar文件夹下有没有你的aar文件。然后运行 1gradle publish 命令，发布你的包。发布成功之后，你可以在你的账户的Packages选项下面看到你发布的包了 使用你的Github Package首先，你需要一个有read权限的库，具体申请方式请看这里。 然后，在你的Android Studio项目的gradle.properties文件中写入： 12gpr.usr=GITHUB_USERID //注意，这里有的导入包的时候会是gpr.user，自己可以改的gpr.key=PERSONAL_ACCESS_TOKEN 然后在你项目的build.gradle的依赖目录中添加 1234567maven { url = uri(&quot;https://maven.pkg.github.com/trustwallet/wallet-core&quot;) credentials { username = project.findProperty(&quot;gpr.user&quot;) as String?: System.getenv(&quot;GITHUB_USER&quot;) password = project.findProperty(&quot;gpr.key&quot;) as String?: System.getenv(&quot;GITHUB_TOKEN&quot;) }} 上面是列举了一个truastwallet的包，你可以改成你自己的地址。然后去你moudle的build.gradle文件中添加依赖就可以了。 其它 如何使用Gradle 如果你是一名Java / Android开发者，那么我推荐你看一下https://developer.android.com/studio/build/building-cmdline?hl=zh-cn 上面就是其他的发布和使用方式/工具，如果没有，我推荐你查看官方课程：https://lab.github.com/githubtraining/github-actions:-publish-to-github-packages 配置后面的GITHUB_USERNAME和GITHUB_TOKEN是什么意思？ 这个是Linux用户用来配置用户名和密码的，你可以把它配置在你的系统变量（~/.bash_profile或者其他）中： 12export GITHUB_USERNAME=&quot;username&quot;export GITHUB_TOKEN=&quot;token&quot; 具体配置方式和配置文件就不多说了。 你还在发布时，通过命令参数配置你的用户名和Token 1gradle publish -Pgpr.user=username -Pgpr.key=token","link":"/2021/09/13/github-package-usage/"},{"title":"Android 沙盒应用浅析","text":"其实这是一个存在很久的概念，只是近几年Android开发者才开始适配。他如同Linux和ios那样，应用单独储存却又可以互相交互。下面就来说一下这其中有什么 1. 沙盒首先看官方的解释 Android 平台利用基于用户的 Linux 保护机制识别和隔离应用资源，可将不同的应用分隔开来，并保护应用和系统免受恶意应用的攻击。为此，Android 会为每个 Android 应用分配一个独一无二的用户 ID (UID)，并让应用在自己的进程中运行。 Android 会使用该 UID 设置一个内核级应用沙盒。内核会在进程级别利用标准的 Linux 机制（例如，分配给应用的用户 ID 和组 ID）实现应用和系统之间的安全防护。默认情况下，应用不能彼此交互，而且对操作系统的访问权限会受到限制。如果应用 A 尝试执行恶意操作（例如在没有权限的情况下读取应用 B 的数据或拨打电话），系统会阻止此类行为，因为应用 A 没有相应的默认用户权限。这一沙盒机制非常简单，可审核，并且基于已有数十年历史的 UNIX 风格的进程用户隔离和文件权限机制。 首先我们要来简单说一下SELinux的概念。SELinux就是Security-Enhanced Linux（安全增强型Linux），https://github.com/SELinuxProject/selinux 。Android 使用SELinux对包括root/su在内的所有进程进行控制强制访问权限（MAC，mandatory access control）。 下面来说一下，各个Android版本之间的应用间保护机制： 5.0 Android只区分了系统APP（pre-app不包括在内）和第三方APP的区别，系统使用MAC将二者分离开来，但是两种APP在相同的SELinux环境中运行 6.0 Android支持了跨用户边界隔离应用。并且对应用主目录上的默认 DAC 权限从 751 更改为 700，这里的权限请看(权限)[../权限] 8.0 中，所有应用都设为使用 seccomp-bpf 过滤器运行，该过滤器可限制允许应用使用的系统调用，从而增强应用/内核边界的安全性 9.0 中，targetSdkVersion &gt;= 28 的所有非特权应用都必须在不同的 SELinux 沙盒中运行，并针对各个应用提供 MAC。这种保护机制可以提升应用隔离效果，防止替换安全默认设置，并且（最重要的是）防止应用的数据可让所有人访问。 10.0 中，文件管理的权限甚至有限，不可以直接访问应用数据文件。APP不可以直接访问/sdcard/DCIM 文件夹，不过APP保留了访问媒体路径的方法。 2. 沙盒内容分享数据文件/二进制文件 ： content provider不多赘述 物理媒体文件 ：储存Google推荐使用MediaStore 进行媒体文件储存，读取时使用MediaStore.Download 读取。 注意，这里的APP的intent必须使用ACTION_OPEN_DOCUMENT 属性。 Google 强调新APP需要使用分区储存，APP在自己data文件下储存内容即可，使用MediaStore进行媒体文件共享。如果你实在需要访问外部数据（之后的高版本系统可能被禁），那么你需要首先判断 Environment.getExternalStorageState() 的返回状态，当返回MEDIA_MOUNTED时，你可以在外部空间进行读写。返回MEDIA_MOUNTED_READ_ONLY时，你只可以进行读取。 共享集合空间的文件访问推荐使用MediaStore、MediaProvider进行适配。 其他权限r=读取属性 //值＝4 w=写入属性 //值＝2 x=执行属性 //值＝1 7=4+2+1 ，5=4+1，3=2+1，6=4+2，0=没有权限 751 = 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 700 依次类推","link":"/2021/09/16/sandbox-in-android/"},{"title":"监听布局内所有的EditText","text":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步，而你又不想写N个databean的时候，你可以试试下面这个控件。 编历布局，看当前布局有几个EditText,然后去监听拿到focus的view。 获取ViewGroup中的EditText方法一： 12345678910111213141516171819202122// 遍历viewGroupfun traverseViewGroup(view: View?): Int { var viewCount = 0 if (null == view) { return 0 } if (view is ViewGroup) { //遍历ViewGroup,是子view加1，是ViewGroup递归调用 for (i in 0 until (view as ViewGroup).childCount) { val child: View = (view as ViewGroup).getChildAt(i) if (child is ViewGroup) { viewCount += traverseViewGroup((view as ViewGroup).getChildAt(i)) } else { viewCount++ } } } else { viewCount++ } return viewCount} 方法二： 123456789101112131415161718192021222324252627fun traverseViewGroup(view: View?): Int { var viewCount = 0 if (null == view) { return 0 } if (view is ViewGroup) { val viewGroup = view as ViewGroup val linkedList: LinkedList&lt;ViewGroup&gt; = LinkedList() linkedList.add(viewGroup) while (!linkedList.isEmpty()) { //removeFirst()删除第一个元素，并返回该元素 val current: ViewGroup = linkedList.removeFirst() viewCount++ //遍历linkedList中第一个viewGroup中的子view for (i in 0 until current.childCount) { if (current.getChildAt(i) is ViewGroup) { linkedList.addLast(current.getChildAt(i) as ViewGroup) } else { viewCount++ } } } } else { viewCount++ } return viewCount } 然后根据 1v.getClassName() == &quot;EditText&quot; 或者 if(v instanceof Button) 判断是不是EditText 在获取到所有Edittext的时候，你就可以统一判断输入状态了……","link":"/2021/09/04/listion-all-edittext-in-layout/"}],"tags":[],"categories":[]}